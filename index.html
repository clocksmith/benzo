<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Graph Builder</title>
    <style>
        :root {
            --bg-color: black;
            --text-color: white;
            --control-bg-color: black;
            --node-color: white;
            --edge-color: white;
            --switch-bg: black;
            --switch-thumb-bg: black;
            --switch-active-bg: white;
            --button-bg: black;
            --button-text-color: white;
            --button-hover-bg: white;
            --input-bg: black;
            --input-text-color: white;
            --input-border-color: white;
            --section-title-color: white;
        }

        .light-mode {
            --bg-color: white;
            --text-color: black;
            --control-bg-color: white;
            --node-color: black;
            --edge-color: black;
            --switch-bg: white;
            --switch-thumb-bg: white;
            --switch-active-bg: black;
            --button-bg: white;
            --button-text-color: black;
            --button-hover-bg: black;
            --input-bg: white;
            --input-text-color: black;
            --input-border-color: black;
            --section-title-color: black;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        body {
            font-family: sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            transition: background-color 0.3s, color 0.3s;
        }

        #controls {
            padding: 20px;
            background-color: var(--control-bg-color);
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 200px;
            height: 100%;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
            overflow-y: auto;
        }

        .control-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .control-section-title {
            color: var(--section-title-color);
            font-weight: bold;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--text-color);
            margin-bottom: 10px;
            font-family: monospace;
        }


        #graphCanvas {
            width: calc(100vw - 200px);
            height: 100%;
            background-color: var(--bg-color);
            border-left: 2px solid var(--text-color);
        }

        .node {
            fill: var(--node-color);
            stroke: none;
        }

        .edge {
            stroke: var(--edge-color);
            stroke-width: 2;
        }

        #darkModeToggleContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            cursor: pointer;
            font-size: 1.5em;
            user-select: none;
        }

        button {
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: 2px solid var(--text-color);
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s, color 0.3s;
            outline: none;
            font-family: monospace;
            font-weight: lighter;
            width: 100%;
            /* Equal button width */
            box-sizing: border-box;
            /* Include padding and border in width */
        }

        button:hover {
            background-color: var(--button-hover-bg);
            color: var(--button-bg);
        }

        .light-mode button:hover {
            color: var(--button-bg);
        }


        button:active {
            background-color: var(--button-text-color);
            color: var(--button-bg);
        }

        input[type="text"] {
            background-color: var(--input-bg);
            color: var(--input-text-color);
            border: 2px solid var(--input-border-color);
            padding: 8px;
            border-radius: 5px;
            font-size: 1em;
            outline: none;
            margin-bottom: 8px;
            /* Input bottom margin */
            width: 100%;
            /* Equal input width */
            box-sizing: border-box;
            /* Include padding and border in width */
        }
    </style>
</head>

<body class="dark-mode">

    <div id="darkModeToggleContainer">
        <span id="darkModeToggle">Ôù∞</span>
    </div>

    <div id="controls">

        <div class="control-section">
            <h3 class="control-section-title">Graph Actions</h3>
            <button id="resetButton">Reset All</button>
            <button id="addNodeButton">Add Node</button>
            <button id="removeNodeButton">Remove Node</button>
            <button id="connectNodesButton">Connect Nodes</button>
        </div>


        <div class="control-section">
            <h3 class="control-section-title">Templates</h3>
            <div style="margin-bottom: 15px;">
                <label for="ringNodesInput" style="display: block; margin-bottom: 5px;">Rings (e.g., [6,12])</label>
                <input type="text" id="ringNodesInput" placeholder="[6,12]">
                <button id="addRingsButton" style="margin-bottom: 8px;">Add Circular Rings</button>
            </div>

            <div>
                <label for="triGridRingsInput" style="display: block; margin-bottom: 5px;">Rings (e.g., 3)</label>
                <input type="text" id="triGridRingsInput" placeholder="3">
                <button id="addTriGridButton" style="margin-bottom: 8px;">Add Triangular Grid</button>
            </div>
        </div>


    </div>
    <svg id="graphCanvas"></svg>

    <script>
        const graphCanvas = document.getElementById('graphCanvas');
        const controls = document.getElementById('controls');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const resetButton = document.getElementById('resetButton');
        const addNodeButton = document.getElementById('addNodeButton');
        const removeNodeButton = document.getElementById('removeNodeButton');
        const connectNodesButton = document.getElementById('connectNodesButton');
        const ringNodesInput = document.getElementById('ringNodesInput');
        const addRingsButton = document.getElementById('addRingsButton');
        const triGridRingsInput = document.getElementById('triGridRingsInput');
        const addTriGridButton = document.getElementById('addTriGridButton');

        let nodes = [];
        let edges = [];
        let nextNodeId = 0;
        let nextEdgeId = 0;
        let selectedNodeId = null;
        let isConnectingNodes = false;
        let darkMode = true;

        function renderGraph() {
            graphCanvas.innerHTML = '';
            const fragment = document.createDocumentFragment();

            edges.forEach(edge => {
                const node1 = nodes.find(node => node.id === edge.node1Id);
                const node2 = nodes.find(node => node.id === edge.node2Id);
                if (node1 && node2) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('class', 'edge');
                    line.setAttribute('x1', node1.x);
                    line.setAttribute('y1', node1.y);
                    line.setAttribute('x2', node2.x);
                    line.setAttribute('y2', node2.y);
                    line.setAttribute('data-edge-id', edge.id);
                    fragment.appendChild(line);
                }
            });

            nodes.forEach(node => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', 'node');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', 10);
                circle.setAttribute('data-node-id', node.id);
                circle.addEventListener('click', () => onNodeClick(node.id));
                fragment.appendChild(circle);
            });

            graphCanvas.appendChild(fragment);
        }

        function createNode(x, y) {
            const node = { id: nextNodeId++, x: x, y: y };
            nodes.push(node);
            renderGraph();
        }

        function removeNode(nodeId) {
            nodes = nodes.filter(node => node.id !== nodeId);
            edges = edges.filter(edge => edge.node1Id !== nodeId && edge.node2Id !== nodeId);
            renderGraph();
        }

        function createEdge(node1Id, node2Id) {
            const edge = { id: nextEdgeId++, node1Id: node1Id, node2Id: node2Id };
            edges.push(edge);
            renderGraph();
        }

        function removeEdge(edgeId) {
            edges = edges.filter(edge => edge.id !== edgeId);
            renderGraph();
        }

        function onNodeClick(nodeId) {
            if (isConnectingNodes) {
                if (selectedNodeId === null) {
                    selectedNodeId = nodeId;
                } else if (selectedNodeId !== nodeId) {
                    createEdge(selectedNodeId, nodeId);
                    selectedNodeId = null;
                    isConnectingNodes = false;
                    connectNodesButton.textContent = 'Connect Nodes';
                } else {
                    selectedNodeId = null;
                }
            }
        }

        function applyRingLayout(ringSizes) {
            nodes = [];
            edges = [];
            nextNodeId = 0;
            const centerX = graphCanvas.clientWidth / 2;
            const centerY = graphCanvas.clientHeight / 2;
            let currentRadius = 40;
            const minNodeSpacing = 40;
            let previousRingNodes = 0;
            const initialRingRadiusIncrement = Math.min(centerX, centerY) * 0.15;

            ringSizes.forEach((numNodes, index) => {
                let ringRadiusIncrement;
                if (index === 0) {
                    ringRadiusIncrement = initialRingRadiusIncrement;
                } else {
                    ringRadiusIncrement = Math.max(minNodeSpacing * previousRingNodes / (2 * Math.PI), currentRadius * 0.3);
                }
                currentRadius += ringRadiusIncrement;


                const angleStep = (2 * Math.PI) / numNodes;
                for (let i = 0; i < numNodes; i++) {
                    const angle = i * angleStep;
                    const x = centerX + currentRadius * Math.cos(angle);
                    const y = centerY + currentRadius * Math.sin(angle);
                    createNode(x, y);
                }
                previousRingNodes = numNodes;
            });
            renderGraph();
        }


        function applyTriangularGridLayout(numRings) {
            nodes = [];
            edges = [];
            nextNodeId = 0;
            const centerX = graphCanvas.clientWidth / 2;
            const centerY = graphCanvas.clientHeight / 2;
            const nodeSpacing = Math.min(centerX, centerY) * 0.2;

            for (let ring = 0; ring < numRings; ring++) {
                let nodesInRing = ring === 0 ? 1 : 6 * ring;
                for (let i = 0; i < nodesInRing; i++) {
                    let angle = (2 * Math.PI / nodesInRing) * i - (ring % 2 === 0 ? 0 : Math.PI / 6);
                    let x = centerX + nodeSpacing * ring * Math.cos(angle);
                    let y = centerY + nodeSpacing * ring * Math.sin(angle);
                    createNode(x, y);
                }
            }
            renderGraph();
        }


        function resetGraph() {
            nodes = [];
            edges = [];
            nextNodeId = 0;
            nextEdgeId = 0;
            renderGraph();
        }

        function toggleDarkMode() {
            darkMode = !darkMode;
            document.body.classList.toggle('light-mode', !darkMode);
        }

        darkModeToggle.addEventListener('click', toggleDarkMode);
        resetButton.addEventListener('click', resetGraph);
        addNodeButton.addEventListener('click', () => {
            createNode(Math.random() * graphCanvas.clientWidth, Math.random() * graphCanvas.clientHeight);
        });

        removeNodeButton.addEventListener('click', () => {
            if (nodes.length > 0) {
                const lastNodeId = nodes[nodes.length - 1].id;
                removeNode(lastNodeId);
            }
        });

        connectNodesButton.addEventListener('click', () => {
            isConnectingNodes = !isConnectingNodes;
            connectNodesButton.textContent = isConnectingNodes ? 'Connecting...' : 'Connect Nodes';
            selectedNodeId = null;
        });

        addRingsButton.addEventListener('click', () => {
            try {
                const ringSizes = JSON.parse(ringNodesInput.value);
                if (Array.isArray(ringSizes) && ringSizes.every(Number.isInteger) && ringSizes.every(size => size > 0)) {
                    applyRingLayout(ringSizes);
                } else {
                    console.error('Invalid ring sizes input. Please use format like [6, 12].');
                }
            } catch (e) {
                console.error('Error parsing ring sizes input:', e);
            }
        });

        addTriGridButton.addEventListener('click', () => {
            const numRings = parseInt(triGridRingsInput.value, 10);
            if (Number.isInteger(numRings) && numRings > 0) {
                applyTriangularGridLayout(numRings);
            } else {
                console.error('Invalid triangular grid rings input. Please enter a positive integer.');
            }
        });


        renderGraph();
        darkMode = true;

    </script>
</body>

</html>