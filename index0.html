<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Graph Builder</title>
    <style>
        :root {
            --bg-color: black;
            --text-color: white;
            --control-bg-color: black;
            --node-color: white;
            --edge-color: white;
            --switch-bg: black;
            --switch-thumb-bg: white;
            --switch-active-bg: white;
            --button-bg: black;
            --button-text-color: white;
            --button-hover-bg: white;
            --input-bg: black;
            --input-text-color: white;
            --input-border-color: white;
            --section-title-color: white;
            --script-control-bg: #111;
            --slider-track-color: white;
            --slider-thumb-color: white;
            --message-color: white;
        }

        .light-mode {
            --bg-color: white;
            --text-color: black;
            --control-bg-color: white;
            --node-color: black;
            --edge-color: black;
            --switch-bg: white;
            --switch-thumb-bg: black;
            --switch-active-bg: black;
            --button-bg: white;
            --button-text-color: black;
            --button-hover-bg: black;
            --input-bg: white;
            --input-text-color: black;
            --input-border-color: black;
            --section-title-color: black;
            --script-control-bg: #eee;
            --slider-track-color: black;
            --slider-thumb-color: black;
            --message-color: black;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        body {
            font-family: sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            transition: background-color, color 0.3s;
        }

        #controls {
            padding: 20px;
            background-color: var(--control-bg-color);
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 200px;
            height: 100%;
            overflow-y: auto;
            align-items: stretch;
        }

        #scriptControls {
            background-color: var(--script-control-bg);
            margin-bottom: 8px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            box-sizing: border-box;
        }

        #scriptSelector {
            background-color: var(--input-bg);
            color: var(--input-text-color);
            border: 2px solid var(--input-border-color);
            padding: 8px;
            border-radius: 5px;
            font-size: 1em;
            outline: none;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
        }

        #playbackControls {
            display: flex;
            gap: 10px;
            width: 100%;
            box-sizing: border-box;
            justify-content: space-between;
        }

        #playbackControls button {
            width: 30%;
            padding: 8px 10px;
            font-size: 0.9em;
        }

        #playbackControls>* {
            flex-grow: 1;
            flex-basis: 0;
        }


        #speedControl {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
            box-sizing: border-box;
        }


        #speedSlider {
            width: 100%;
            appearance: none;
            height: 2px;
            background: var(--slider-track-color);
            outline: none;
            opacity: 1;
            border-radius: 1px;
            cursor: pointer;
            border: 2px solid var(--text-color);
            -webkit-appearance: none;
            appearance: none;
            -moz-appearance: none;
        }

        #speedSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            -moz-appearance: none;
            width: 14px;
            height: 14px;
            background-color: var(--slider-thumb-color);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid var(--text-color);
        }

        #speedSlider::-moz-range-thumb {
            -webkit-appearance: none;
            appearance: none;
            -moz-appearance: none;
            width: 14px;
            height: 14px;
            background-color: var(--slider-thumb-color);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid var(--text-color);
        }


        #speedLabel {
            text-align: center;
            font-size: 0.8em;
        }

        #scriptStepDisplay {
            text-align: center;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .control-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
            width: 100%;
            box-sizing: border-box;
        }

        .control-section-title {
            color: var(--section-title-color);
            font-weight: bold;
            padding-bottom: 5px;
            border-bottom: 0.5px dashed var(--text-color);
            margin-bottom: 10px;
            font-family: monospace;
        }


        #graphCanvas {
            width: calc(100vw - 200px);
            height: 100%;
            background-color: var(--bg-color);
            border-left: 2px solid var(--text-color);
        }

        .node {
            fill: var(--node-color);
            stroke: none;
        }

        .edge {
            stroke: var(--edge-color);
            stroke-width: 2;
        }

        #darkModeToggleContainer {
            position: absolute;
            top: 8px;
            right: 8px;
            cursor: pointer;
            font-size: 2em;
            user-select: none;
        }

        button,
        select {
            background-color: var(--button-bg);
            color: var(--button-text-color);
            border: 2px solid var(--text-color);
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color, color 0.3s;
            outline: none;
            font-family: monospace;
            font-weight: lighter;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
        }

        button:hover {
            background-color: var(--button-hover-bg);
            color: var(--button-bg);
        }

        .light-mode button:hover {
            color: var(--button-bg);
        }


        button:active {
            background-color: var(--button-text-color);
            color: var(--button-bg);
        }

        input[type="text"] {
            background-color: var(--input-bg);
            color: var(--input-text-color);
            border: 2px solid var(--input-border-color);
            padding: 8px;
            border-radius: 5px;
            font-size: 1em;
            outline: none;
            margin-bottom: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        .step-message {
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            fill: var(--message-color);
            font-size: 1.2em;
            text-anchor: middle;
            dominant-baseline: hanging;
            y: 60px;
        }

        .step-message.visible {
            opacity: 1;
        }

        .message-history {
            fill: var(--message-color);
            opacity: 0.6;
            font-size: 0.8em;
            text-anchor: middle;
            dominant-baseline: hanging;
        }

        #focusArea {
            opacity: 0.2;
            stroke: var(--text-color);
            stroke-width: 1;
            fill: none;
        }
    </style>
</head>

<body class="dark-mode">

    <div id="darkModeToggleContainer">
        <span id="darkModeToggle">üù£</span>
    </div>

    <div id="controls">
        <button id="resetButton">Reset All</button>

        <div id="scriptControls">
            <select id="scriptSelector">
                <option value="">Select Script</option>
                <option value="ring_script">Ring Script</option>
                <option value="grid_script">Grid Script</option>
                <option value="path_script">Path Script</option>
            </select>
            <div id="playbackControls">
                <button id="stepBackwardButton">Back</button>
                <button id="playPauseButton">Play</button>
                <button id="stepForwardButton">Next</button>
            </div>
            <div id="speedControl">
                <label id="speedLabel" for="speedSlider">Animation Speed (ms per step)</label>
                <input type="range" id="speedSlider" min="100" max="10000" value="500" step="100">
            </div>
            <span id="scriptStepDisplay">Step: -</span>
        </div>

        <div class="control-section">
            <h3 class="control-section-title">Templates</h3>
            <div style="margin-bottom: 15px;">
                <label for="ringNodesInput" style="display: block; margin-bottom: 5px;">Rings (e.g., [6,12])</label>
                <input type="text" id="ringNodesInput" placeholder="[6,12]">
                <button id="addRingsButton" style="margin-bottom: 8px;">Add Circular Rings</button>
            </div>

            <div>
                <label for="triGridRingsInput" style="display: block; margin-bottom: 5px;">Rings (e.g., 3)</label>
                <input type="text" id="triGridRingsInput" placeholder="3">
                <button id="addTriGridButton" style="margin-bottom: 8px;">Add Triangular Grid</button>
            </div>
        </div>

        <div class="control-section">
            <h3 class="control-section-title">Graph Actions</h3>
            <button id="addNodeButton">Add Node</button>
            <button id="removeNodeButton">Remove Node</button>
            <button id="connectNodesButton">Connect Nodes</button>
        </div>


    </div>
    <svg id="graphCanvas">
        <rect id="focusArea" x="10%" y="150" width="80%" height="100" />
        <text id="currentStepMessage" class="step-message" x="50%" y="60"></text>
        <g id="messageHistory"></g>
    </svg>

    <script>
        const graphCanvas = document.getElementById('graphCanvas');
        const controls = document.getElementById('controls');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const resetButton = document.getElementById('resetButton');
        const addNodeButton = document.getElementById('addNodeButton');
        const removeNodeButton = document.getElementById('removeNodeButton');
        const connectNodesButton = document.getElementById('connectNodesButton');
        const ringNodesInput = document.getElementById('ringNodesInput');
        const addRingsButton = document.getElementById('addRingsButton');
        const triGridRingsInput = document.getElementById('triGridRingsInput');
        const addTriGridButton = document.getElementById('addTriGridButton');
        const focusArea = document.getElementById('focusArea');

        const scriptSelector = document.getElementById('scriptSelector');
        const stepBackwardButton = document.getElementById('stepBackwardButton');
        const playPauseButton = document.getElementById('playPauseButton');
        const stepForwardButton = document.getElementById('stepForwardButton');
        const speedSlider = document.getElementById('speedSlider');
        const speedLabel = document.getElementById('speedLabel');
        const scriptStepDisplay = document.getElementById('scriptStepDisplay');
        const currentStepMessage = document.getElementById('currentStepMessage');
        const messageHistory = document.getElementById('messageHistory');


        let nodes = [];
        let edges = [];
        let nextNodeId = 0;
        let nextEdgeId = 0;
        let selectedNodeIds = [];
        let focusNodes = [];
        let focusEdges = [];
        let nextFocusNodeId = 0;
        let nextFocusEdgeId = 0;

        let isConnectingNodes = false;
        let darkMode = true;

        let currentScript = null;
        let scriptSteps = [];
        let currentStepIndex = -1;
        let isPlaying = false;
        let playSpeed = 500;
        let playInterval;
        let stepDelay = 500;
        let messageHistoryArray = [];


        const scripts = {
            "ring_script": {
                "step1": { "reset": null, "message": "Start with a clean slate" },
                "step2": { "add_circular_rings": [6], "message": "Adding a ring of 6 nodes" },
                "step3": { "add_node": null, "message": "Adding two individual nodes" },
                "step4": { "add_node": null, "message": " " },
                "step5": { "connect_nodes": { "node1": "0", "node2": "1" }, "message": "Connecting the first two nodes" }
            },
            "grid_script": {
                "step1": { "reset": null, "message": "Resetting for grid script" },
                "step2": { "add_triangular_grid": 3, "message": "Creating a triangular grid of 3 rings" },
                "step3": { "add_node": null, "message": "Adding and removing a node" },
                "step4": { "remove_node": null, "message": " " },
                "step5": { "connect_nodes": { "node1": "5", "node2": "6" }, "message": "Connecting nodes in the grid" }
            },
            "path_script": {
                "step1": { "reset": null, "message": "Reset graph for path script" },
                "step2": { "add_circular_rings": [8], "message": "Adding initial ring" },
                "step3": { "connect_nodes": { "node1": "0", "node2": "1" }, "message": "Connect 0 and 1" },
                "step4": { "connect_nodes": { "node1": "1", "node2": "2" }, "message": "Connect 1 and 2" },
                "step5": { "connect_nodes": { "node1": "2", "node2": "3" }, "message": "Connect 2 and 3" },
                "step6": { "connect_nodes": { "node1": "3", "node2": "4" }, "message": "Connect 3 and 4" },
                "step7": { "connect_nodes": { "node1": "4", "node2": "5" }, "message": "Connect 4 and 5" },
                "step8": { "connect_nodes": { "node1": "5", "node2": "6" }, "message": "Connect 5 and 6" },
                "step9": { "connect_nodes": { "node1": "6", "node2": "7" }, "message": "Connect 6 and 7" },
                "step10": { "connect_nodes": { "node1": "7", "node2": "0" }, "message": "Connect 7 and 0 to close ring" },

                "step11": { "connect_nodes": { "node1": "0", "node2": "2" }, "message": "Adding diagonals" },
                "step12": { "connect_nodes": { "node1": "2", "node2": "4" }, "message": " " },
                "step13": { "connect_nodes": { "node1": "4", "node2": "6" }, "message": " " },
                "step14": { "connect_nodes": { "node1": "6", "node2": "0" }, "message": " " },

                "step15": { "select_path": ["0", "1", "2", "3", "4", "5", "6", "7"], "message": "Selecting the ring path" },
                "step16": { "copy_move_to_focus": null, "message": "Copying ring path to focus area" },
                "step17": { "straighten_path": null, "message": "Straightening the ring path" },
                "step18": { "compress_path": null, "message": "Compressing the straightened path" },
                "step19": { "add_compressed_path_to_graph": null, "message": "Adding compressed path back to main graph" },

                "step20": { "select_path": ["0", "2", "4", "6"], "message": "Selecting diagonal path" },
                "step21": { "copy_move_to_focus": null, "message": "Copying diagonal path to focus area" },
                "step22": { "straighten_path": null, "message": "Straightening diagonal path in focus" },
                "step23": { "compress_path": null, "message": "Compressing diagonal path" },
                "step24": { "add_compressed_path_to_graph": null, "message": "Adding diagonal compressed path to graph" },

                "step25": { "select_path": ["1", "3", "5", "7"], "message": "Selecting other diagonal path" },
                "step26": { "copy_move_to_focus": null, "message": "Copying other diagonal path to focus area" },
                "step27": { "straighten_path": null, "message": "Straightening other diagonal path" },
                "step28": { "compress_path": null, "message": "Compressing other diagonal path" },
                "step29": { "add_compressed_path_to_graph": null, "message": "Adding compressed other diagonal path to graph" },
                "step30": { "message": "Path script complete!" }
            }
        };


        function renderGraph() {
            graphCanvas.innerHTML = '';
            const fragment = document.createDocumentFragment();

            edges.forEach(edge => {
                const node1 = nodes.find(node => node.id === edge.node1Id);
                const node2 = nodes.find(node => node.id === edge.node2Id);
                if (node1 && node2) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('class', 'edge');
                    line.setAttribute('x1', node1.x);
                    line.setAttribute('y1', node1.y);
                    line.setAttribute('x2', node2.x);
                    line.setAttribute('y2', node2.y);
                    line.setAttribute('data-edge-id', edge.id);
                    fragment.appendChild(line);
                }
            });

            focusEdges.forEach(edge => {
                const node1 = focusNodes.find(node => node.id === edge.node1Id);
                const node2 = focusNodes.find(node => node.id === edge.node2Id);
                if (node1 && node2) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('class', 'edge');
                    line.setAttribute('stroke-dasharray', '5,5');
                    line.setAttribute('x1', node1.x);
                    line.setAttribute('y1', node1.y);
                    line.setAttribute('x2', node2.x);
                    line.setAttribute('y2', node2.y);
                    line.setAttribute('data-edge-id', edge.id);
                    fragment.appendChild(line);
                }
            });


            nodes.forEach(node => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', 'node');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', 10);
                circle.setAttribute('data-node-id', node.id);
                circle.classList.toggle('selected', selectedNodeIds.includes(node.id));
                circle.addEventListener('click', () => onNodeClick(node.id));
                fragment.appendChild(circle);
            });
            focusNodes.forEach(node => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('class', 'node');
                circle.setAttribute('fill', 'green');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', 8);
                circle.setAttribute('data-focus-node-id', node.id);
                fragment.appendChild(circle);
            });


            fragment.appendChild(currentStepMessage);
            fragment.appendChild(messageHistory);
            fragment.appendChild(focusArea);


            graphCanvas.appendChild(fragment);
        }

        function createNode(x, y) {
            const node = { id: nextNodeId++, x: x, y: y };
            nodes.push(node);
            renderGraph();
            return node.id.toString();
        }

        function removeNode(nodeId) {
            nodes = nodes.filter(node => node.id !== nodeId);
            edges = edges.filter(edge => edge.node1Id !== nodeId && edge.node2Id !== nodeId);
            renderGraph();
        }

        function createEdge(node1Id, node2Id) {
            const edge = { id: nextEdgeId++, node1Id: node1Id, node2Id: node2Id };
            edges.push(edge);
            renderGraph();
        }

        function removeEdge(edgeId) {
            edges = edges.filter(edge => edge.id !== edgeId);
            renderGraph();
        }

        function onNodeClick(nodeId) {
            if (isConnectingNodes) {
                if (selectedNodeId === null) {
                    selectedNodeId = nodeId;
                } else if (selectedNodeId !== nodeId) {
                    createEdge(selectedNodeId, nodeId);
                    selectedNodeId = null;
                    isConnectingNodes = false;
                    connectNodesButton.textContent = 'Connect Nodes';
                } else {
                    selectedNodeId = null;
                }
            }
        }

        function applyRingLayout(ringSizes) {
            nodes = [];
            edges = [];
            nextNodeId = 0;
            const centerX = graphCanvas.clientWidth / 2;
            const centerY = graphCanvas.clientHeight / 2;
            let currentRadius = 40;
            const minNodeSpacing = 40;
            let previousRingNodes = 0;
            const initialRingRadiusIncrement = Math.min(centerX, centerY) * 0.15;
            let createdNodeIds = [];

            ringSizes.forEach((numNodes, index) => {
                let ringRadiusIncrement;
                if (index === 0) {
                    ringRadiusIncrement = initialRingRadiusIncrement;
                } else {
                    ringRadiusIncrement = Math.max(minNodeSpacing * previousRingNodes / (2 * Math.PI), currentRadius * 0.3);
                }
                currentRadius += ringRadiusIncrement;


                const angleStep = (2 * Math.PI) / numNodes;
                for (let i = 0; i < numNodes; i++) {
                    const angle = i * angleStep;
                    const x = centerX + currentRadius * Math.cos(angle);
                    const y = centerY + currentRadius * Math.sin(angle);
                    createdNodeIds.push(createNode(x, y));
                }
                previousRingNodes = numNodes;
            });
            renderGraph();
            return createdNodeIds;
        }


        function applyTriangularGridLayout(numRings) {
            nodes = [];
            edges = [];
            nextNodeId = 0;
            const centerX = graphCanvas.clientWidth / 2;
            const centerY = graphCanvas.clientHeight / 2;
            const nodeSpacing = Math.min(centerX, centerY) * 0.2;
            let createdNodeIds = [];

            for (let ring = 0; ring < numRings; ring++) {
                let nodesInRing = ring === 0 ? 1 : 6 * ring;
                for (let i = 0; i < nodesInRing; i++) {
                    let angle = (2 * Math.PI / nodesInRing) * i - (ring % 2 === 0 ? 0 : Math.PI / 6);
                    let x = centerX + nodeSpacing * ring * Math.cos(angle);
                    let y = centerY + nodeSpacing * ring * Math.sin(angle);
                    createdNodeIds.push(createNode(x, y));
                }
            }
            renderGraph();
            return createdNodeIds;
        }


        function resetGraph() {
            nodes = [];
            edges = [];
            nextNodeId = 0;
            nextEdgeId = 0;
            selectedNodeIds = [];
            resetFocusArea();
            renderGraph();
        }

        function resetFocusArea() {
            focusNodes = [];
            focusEdges = [];
            nextFocusNodeId = 0;
            nextFocusEdgeId = 0;
        }


        function toggleDarkMode() {
            darkMode = !darkMode;
            document.body.classList.toggle('light-mode', !darkMode);
        }

        function loadScript(scriptName) {
            currentScript = scripts[scriptName];
            if (currentScript) {
                scriptSteps = Object.entries(currentScript);
                currentStepIndex = -1;
                stopPlaying();
                renderGraph();
                updateStepDisplay();
            } else {
                console.error(`Script '${scriptName}' not found.`);
            }
        }

        function executeStep(step) {
            const action = step[1];
            currentStepMessage.classList.remove('visible');
            messageHistoryArray.push(currentStepMessage.textContent);
            if (messageHistoryArray.length > 5) {
                messageHistoryArray.shift();
            }
            updateMessageHistory();


            if (action.reset !== undefined) {
                resetGraph();
            } else if (action.add_circular_rings !== undefined) {
                applyRingLayout(action.add_circular_rings);
            } else if (action.add_triangular_grid !== undefined) {
                applyTriangularGridLayout(action.add_triangular_grid);
            } else if (action.add_node !== undefined) {
                createNode(Math.random() * graphCanvas.clientWidth, Math.random() * graphCanvas.clientHeight);
            } else if (action.remove_node !== undefined) {
                if (nodes.length > 0) {
                    removeNode(nodes[nodes.length - 1].id);
                }
            } else if (action.connect_nodes !== undefined) {
                const node1 = nodes.find(n => n.id === parseInt(action.connect_nodes.node1));
                const node2 = nodes.find(n => n.id === parseInt(action.connect_nodes.node2));
                if (node1 && node2) {
                    createEdge(node1.id, node2.id);
                } else {
                    console.error("Nodes for connection not found:", action.connect_nodes);
                }
            } else if (action.select_path !== undefined) {
                selectPath(action.select_path);
            } else if (action.copy_move_to_focus !== undefined) {
                copyMovePathToFocus();
            } else if (action.straighten_path !== undefined) {
                straightenPathInFocus();
            } else if (action.compress_path !== undefined) {
                compressPathInFocus();
            } else if (action.add_compressed_path_to_graph !== undefined) {
                addCompressedPathToGraph();
            }


            if (action.message !== undefined && action.message.trim() !== "") {
                currentStepMessage.textContent = action.message;
                void currentStepMessage.offsetWidth;
                currentStepMessage.classList.add('visible');
            } else {
                currentStepMessage.textContent = "";
            }
            renderGraph();
        }

        function updateMessageHistory() {
            messageHistory.innerHTML = '';
            const fragment = document.createDocumentFragment();
            messageHistoryArray.forEach((message, index) => {
                const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textElement.setAttribute('class', 'message-history');
                textElement.setAttribute('x', '50%');
                textElement.setAttribute('y', 5 + index * 12);
                textElement.textContent = message;
                fragment.appendChild(textElement);
            });
            messageHistory.appendChild(fragment);
        }


        function stepForward() {
            if (!currentScript) return;
            stopPlaying();
            if (currentStepIndex < scriptSteps.length - 1) {
                currentStepIndex++;
                executeStep(scriptSteps[currentStepIndex]);
                updateStepDisplay();
            } else {
                stopPlaying();
                currentStepIndex = scriptSteps.length - 1;
                updateStepDisplay();
            }
        }

        function stepBackward() {
            stopPlaying();
            if (currentScript && currentStepIndex > 0) {
                resetGraph();
                for (let i = 0; i < currentStepIndex; i++) {
                    executeStep(scriptSteps[i]);
                }
                currentStepIndex--;
                updateStepDisplay();

            } else if (currentStepIndex === 0) {
                resetGraph();
                currentStepIndex = -1;
                updateStepDisplay();
            }
        }


        function playScript() {
            if (currentScript && !isPlaying) {
                isPlaying = true;
                playPauseButton.textContent = 'Playing...';
                playSpeed = parseInt(speedSlider.value, 10);
                stepDelay = playSpeed;
                playInterval = setInterval(scriptStep, stepDelay);
            }
        }

        function scriptStep() {
            if (currentStepIndex < scriptSteps.length - 1) {
                stepForward();
            } else {
                stopPlaying();
                updateStepDisplay();
            }
        }


        function stopPlaying() {
            if (isPlaying) {
                isPlaying = false;
                clearInterval(playInterval);
                playPauseButton.textContent = 'Play';
            }
        }


        function togglePlayPause() {
            if (isPlaying) {
                stopPlaying();
            } else {
                playScript();
            }
        }

        function updateStepDisplay() {
            scriptStepDisplay.textContent = currentScript ? `Step: ${currentStepIndex + 1}/${scriptSteps.length}` : 'Step: -';
        }

        function selectPath(nodeIds) {
            selectedNodeIds = nodeIds.map(id => parseInt(id));
            renderGraph();
        }

        function copyMovePathToFocus() {
            resetFocusArea();
            selectedNodeIds.forEach(nodeId => {
                const originalNode = nodes.find(n => n.id === nodeId);
                if (originalNode) {
                    const focusNode = { ...originalNode, id: nextFocusNodeId++ };
                    focusNodes.push(focusNode);
                }
            });


            selectedNodeIds.forEach(nodeId1 => {
                selectedNodeIds.forEach(nodeId2 => {
                    if (nodeId1 === nodeId2) return;
                    let originalEdge = edges.find(e => (e.node1Id === nodeId1 && e.node2Id === nodeId2) || (e.node1Id === nodeId2 && e.node2Id === nodeId1));
                    if (originalEdge) {
                        const focusNode1 = focusNodes.find(fn => fn.id === focusNodes.findIndex(f => f.id === originalEdge.node1Id));
                        const focusNode2 = focusNodes.find(fn => fn.id === focusNodes.findIndex(f => f.id === originalEdge.node2Id));
                        if (!focusEdges.some(e => (e.node1Id === focusNode1.id && e.node2Id === focusNode2.id) || (e.node1Id === focusNode2.id && e.node2Id === focusNode1.id))) {
                            const focusEdge = { ...originalEdge, id: nextFocusEdgeId++, node1Id: focusNode1.id, node2Id: focusNode2.id };
                            focusEdges.push(focusEdge);
                        }
                    }
                });
            });
            positionFocusNodes();
            renderGraph();
        }

        function positionFocusNodes() {
            if (focusNodes.length === 0) return;

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            focusNodes.forEach(node => {
                minX = Math.min(minX, node.x);
                maxX = Math.max(maxX, node.x);
                minY = Math.min(minY, node.y);
                maxY = Math.max(maxY, node.y);
            });

            const pathWidth = maxX - minX;
            const pathHeight = maxY - minY;
            const pathCenterX = minX + pathWidth / 2;
            const pathCenterY = minY + pathHeight / 2;

            const focusAreaElement = focusArea.getBoundingClientRect();
            const focusCenterX = focusAreaElement.x + focusAreaElement.width / 2;
            const focusCenterY = focusAreaElement.y + focusAreaElement.height / 2;

            const offsetX = focusCenterX - pathCenterX;
            const offsetY = focusCenterY - pathCenterY;

            focusNodes.forEach(node => {
                node.x += offsetX;
                node.y += offsetY;
            });
        }


        function straightenPathInFocus() {
            positionFocusNodes();
            renderGraph();
        }

        function compressPathInFocus() {
            focusNodes = focusNodes.filter((node, index) => index % 2 === 0);
            focusEdges = focusEdges.filter(edge => focusNodes.some(node => node.id === edge.node1Id) && focusNodes.some(node => node.id === edge.node2Id));
            positionFocusNodes();
            renderGraph();
        }

        function addCompressedPathToGraph() {
            focusNodes.forEach(fNode => {
                const newNode = { ...fNode, id: nextNodeId++, x: fNode.x, y: fNode.y }; // Use focus node positions
                nodes.push(newNode);
                focusEdges.forEach(fEdge => {
                    if ((fEdge.node1Id === fNode.id)) {
                        const n1 = nodes.find(n => n.id === newNode.id);
                        const n2 = nodes.find(n => n.id === focusNodes.find(fn => fn.id === fEdge.node2Id).id);
                        if (n1 && n2) {
                            createEdge(n1.id, n2.id);
                        }
                    }
                });
            });
            focusEdges.forEach(fEdge => {
                const focusNode1 = focusNodes.find(fn => fn.id === fEdge.node1Id);
                const focusNode2 = focusNodes.find(fn => fn.id === fEdge.node2Id);
                const n1 = nodes.find(n => n.x === focusNode1.x && n.y === focusNode1.y); // Find new node by position
                const n2 = nodes.find(n => n.x === focusNode2.x && n.y === focusNode2.y); // Find new node by position
                if (n1 && n2) {
                    createEdge(n1.id, n2.id);
                }
            });
            resetFocusArea();
            renderGraph();
        }


        darkModeToggle.addEventListener('click', toggleDarkMode);
        resetButton.addEventListener('click', resetGraph);
        addNodeButton.addEventListener('click', () => {
            createNode(Math.random() * graphCanvas.clientWidth, Math.random() * graphCanvas.clientHeight);
        });

        removeNodeButton.addEventListener('click', () => {
            if (nodes.length > 0) {
                removeNode(nodes[nodes.length - 1].id);
            }
        });

        connectNodesButton.addEventListener('click', () => {
            isConnectingNodes = !isConnectingNodes;
            connectNodesButton.textContent = isConnectingNodes ? 'Connecting...' : 'Connect Nodes';
            selectedNodeId = null;
        });

        addRingsButton.addEventListener('click', () => {
            try {
                const ringSizes = JSON.parse(ringNodesInput.value);
                if (Array.isArray(ringSizes) && ringSizes.every(Number.isInteger) && ringSizes.every(size => size > 0)) {
                    applyRingLayout(ringSizes);
                } else {
                    console.error('Invalid ring sizes input. Please use format like [6, 12].');
                }
            } catch (e) {
                console.error('Error parsing ring sizes input:', e);
            }
        });

        addTriGridButton.addEventListener('click', () => {
            const numRings = parseInt(triGridRingsInput.value, 10);
            if (Number.isInteger(numRings) && numRings > 0) {
                applyTriangularGridLayout(numRings);
            } else {
                console.error('Invalid triangular grid rings input. Please enter a positive integer.');
            }
        });

        scriptSelector.addEventListener('change', (event) => {
            loadScript(event.target.value);
        });
        stepForwardButton.addEventListener('click', stepForward);
        stepBackwardButton.addEventListener('click', stepBackward);
        playPauseButton.addEventListener('click', togglePlayPause);
        speedSlider.addEventListener('input', (event) => {
            playSpeed = parseInt(event.target.value, 10);
            stepDelay = playSpeed;
            if (isPlaying) {
                stopPlaying();
                playScript();
            }
        });


        renderGraph();
        darkMode = true;
        updateStepDisplay();

    </script>
</body>

</html>